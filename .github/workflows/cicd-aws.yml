# This workflow will build and push a new container image to Amazon ECR,
#
# To use this workflow, you will need to complete the following set-up steps:
#
# 1. Create an ECR repository to store your images.
#    For example: `aws ecr create-repository --repository-name my-ecr-repo --region us-east-2`.
#    Replace the value of the `ECR_REPOSITORY` environment variable in the workflow below with your repository's name.
#    Replace the value of the `AWS_REGION` environment variable in the workflow below with your repository's region.
#
#
# 4. Store an IAM user access key in GitHub Actions secrets named `AWS_ACCESS_KEY_ID` and `AWS_SECRET_ACCESS_KEY`.
#    See the documentation for each action used below for the recommended IAM policies for this IAM user,
#    and best practices on handling the access key credentials.

name: CICD_AWS_EC2_ECR

on:

  workflow_dispatch:
  
  #push:
  #  branches:
  #    - "develop"
env:
  AWS_REGION: ${{ secrets.AWS_REGION }}                                  # set this to your preferred AWS region, e.g. us-west-1
  ECR_REPOSITORY: ${{ secrets.AWS_ECR_REPOSITORY }}                      # set this to your Amazon ECR repository name
  

permissions:
  contents: read

jobs:

  #------------------------------------
  #  CI Scan JS code (njsscan)
  #-------------------------------------
  # Commented because repo branch scan fails throwing an error
  #njsscan:
  #  name: ci njsscan check
  #  runs-on: ubuntu-latest
  #  steps:c
  #  - name: Checkout the code
  #    uses: actions/checkout@v2
  #  - name: nodejsscan scan
  #    id: njsscan
  #    uses: ajinabraham/njsscan-action@master
  #    with:
  #      args: '.'
    #- name: Mattermost Notification
    #  uses: tferreira/matterfy@releases/v1
    #  if: always()
    #  with:
    #    type: ${{ job.status }}
    #    job_name: '*security composition analysis*'
    #    channel: 'aws-cicd-pipeline'
    #    url: ${{ secrets.SLACK_WEBHOOK }}
   
 ##------------------------------------
 ## CI Build and Test code
 ##-------------------------------------
 #ci:
 #  name: ci build and test
 #  runs-on: ubuntu-latest
 #  strategy:
 #    matrix:
 #      #node-version: [10.x, 12.x, 14.x, 15.x]
 #      node-version: [14.x]
 #  steps:
 #  
 #  - name: Checkout the code
 #    uses: actions/checkout@v2    
 #    
 #  - name: Use Node.js ${{ matrix.node-version }}
 #    uses: actions/setup-node@v1
 #  
 #  - name: Install Dependencies
 #    id:  idci
 #    run: npm ci
 #    continue-on-error: true
 #    
 #  # if package.json and package-lock.json files are unsync. then npm ci fails,
 #  # we need to generate lock file again with package.json.
 #  - name: Check npm ci status. if fails regen lock file and install dependencies
 #    if: steps.idci.outcome == 'failure'
 #    run: |
 #      npm install --package-lock-only
 #      npm ci
 #      
 #  - name: Test code
 #    run: npm test
 #    
 #  - name: Build code
 #    run: npm run build --if-present

  #------------------------------------------
  # CD Build Docker Image and Push to ECR
  #------------------------------------------
 cd:
  name: cd push image
  runs-on: ubuntu-latest
  outputs:
      output1: ${{ steps.buildimg.outputs.dockImgECR_REG }}
      output2: ${{ steps.buildimg.outputs.dockImgECR_REPO }}
      output3: ${{ steps.buildimg.outputs.dockImgECR_IMG_TAG }}
      
      
  #needs: ci
    
  steps:
    - name: Checkout
      uses: actions/checkout@v3
      
    # Create .env file  
    - name: Create env file 
      run: |
          touch .env
          echo JWT_SECRET=${{ secrets.JWT_SECRET }} >> .env
          echo DB_USERNAME=${{ secrets.POSTGRES_USER }} >> .env
          echo DB_PASSWORD=${{ secrets.POSTGRES_PASSWORD }} >> .env
          echo DB_HOSTNAME=${{ secrets.POSTGRES_HOST }} >> .env
          echo DB_PORT=${{ secrets.POSTGRES_PORT }} >> .env
          echo SCHEMA_NAME=${{ secrets.SCHEMA_NAME }} >> .env
          echo NODE_ENV=${{ secrets.NODE_ENV }} >> .env
          echo SESSION_SECRET=${{ secrets.SESSION_SECRET }} >> .env
          echo SALT=${{ secrets.SALT }} >> .env 
          echo MULTER_FILE_SIZE_LIMIT=100 >> .env 
          echo MULTER_FIELD_SIZE_LIMIT=10 >> .env 
          echo BODY_SIZE_LIMIT=10 >> .env 
          cat .env
          
    # echo SERVER_ADDRESS=${{ secrets.NODE_SERVER }} >> .env
    # echo PORT=${{ secrets.NODE_PORT }} >> .env
          
    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v1
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.AWS_REGION }}

    - name: Login to Amazon ECR
      id: login-ecr
      uses: aws-actions/amazon-ecr-login@v1

    - name: Build, tag, and push image to Amazon ECR
      id: buildimg
      env:
        ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
        IMAGE_TAG: latest       # ${{ github.sha }}
      run: |
        # Build a docker image and push it to ECR
        #docker build -t $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG .
        #docker push $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG
        echo "::set-output name=dockImgECR_REG::$ECR_REGISTRY"
        echo "::set-output name=dockImgECR_REPO::$ECR_REPOSITORY"
        echo "::set-output name=dockImgECR_IMG_TAG::$IMAGE_TAG"
        echo "IMAGEURL::$ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG"
    
        
    - name: print img url
      run: echo "Docker image url ${{ steps.buildimg.outputs.dockerImageUrltwo }}"
      
 
  #------------------------------------------
  # CD Deploy app image to EC2
  #------------------------------------------
 deploy:
   name: cd deploy image
   runs-on: ubuntu-latest
   needs: cd
   steps:

    - name: print app url
      run:  echo "this is image url ${{needs.cd.outputs.output1}}/${{needs.cd.outputs.output2}}:${{needs.cd.outputs.output3}}" 


  
